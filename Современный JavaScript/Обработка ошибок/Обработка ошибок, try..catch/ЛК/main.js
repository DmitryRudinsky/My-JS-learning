// Неважно, насколько мы хороши в программировании, иногда наши скрипты содержат
// ошибки. Они могут возникать из-за наших промахов, неожиданного ввода пользователя,
// неправильного ответа сервера и по тысяче других причин.
// Обычно скрипт в случае ошибки «падает» (сразу же останавливается), с выводом ошибки в
// консоль.
// Но есть синтаксическая конструкция try..catch , которая позволяет «ловить» ошибки и
// вместо падения делать что-то более осмысленное.

// Синтаксис «try…catch»
// Конструкция try..catch состоит из двух основных блоков: try , и затем catch :
// Работает она так:
// 1. Сначала выполняется код внутри блока try {...} .
// 2. Если в нём нет ошибок, то блок catch(err) игнорируется: выполнение доходит до
// конца try и потом далее, полностью пропуская catch .
// 3. Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления
// переходит в начало catch(err) . Переменная err (можно использовать любое имя)
// содержит объект ошибки с подробной информацией о произошедшем.
// Таким образом, при ошибке в блоке try {…} скрипт не «падает», и мы получаем
// возможность обработать ошибку внутри catch .

// Чтобы try..catch работал, код должен быть выполнимым. Другими словами, это
// должен быть корректный JavaScript-код.
// Он не сработает, если код синтаксически неверен, например, содержит несовпадающее
// количество фигурных скобок

try {
    // код...
    } catch (err) {
    // обработка ошибки
}



// Объект ошибки
// Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот
// объект передаётся как аргумент в блок catch :
// Для всех встроенных ошибок этот объект имеет два основных свойства:
// name
// Имя ошибки. Например, для неопределённой переменной это "ReferenceError" .
// message
// Текстовое сообщение о деталях ошибки.
// В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых
// широко используемых и поддерживаемых – это:
// stack
// Текущий стек вызова: строка, содержащая информацию о последовательности вложенных
// вызовов, которые привели к ошибке. Используется в целях отладки.


try {
    lalala; // ошибка, переменная не определена!
} catch(err) {
    alert(err.name); // ReferenceError
    alert(err.message); // lalala is not defined
    alert(err.stack); // ReferenceError: lalala is not defined at (...стек вызовов)
    // Можем также просто вывести ошибку целиком
    // Ошибка приводится к строке вида "name: message"
    alert(err); // ReferenceError: lalala is not defined
    }


// Напишем короткий код, который использует try...catch во время работы с JSON
// Иногда случается так, что parse не может обработать строку

let json = "Некорректный JSON";
try{
    let user = JSON.parse(json);
    alert(user.name);
}catch(err){
    //Из-за очевидной ошибки данный, выполнение кода переходит сюда
    alert("Извините, в данных ошибка.");
    alert(err.name);
    alert(err.message);
}

// Здесь мы используем блок catch только для вывода сообщения, но мы также можем
// сделать гораздо больше: отправить новый сетевой запрос, предложить посетителю
// альтернативный способ, отослать информацию об ошибке на сервер для логирования, …
// Всё лучше, чем просто «падение».


// Что если json синтаксически корректен, но не содержит необходимого свойства name ?
// Здесь JSON.parse выполнится без ошибок, но на самом деле отсутствие свойства name
// для нас ошибка.
// Для того, чтобы унифицировать обработку ошибок, мы воспользуемся оператором throw .

// Оператор throw генерирует ошибку.
// Синтаксис:
// throw <объект ошибки>

// Технически в качестве объекта ошибки можно передать что угодно. Это может быть даже
// примитив, число или строка, но всё же лучше, чтобы это был объект, желательно со
// свойствами name и message (для совместимости со встроенными ошибками).
// В JavaScript есть множество встроенных конструкторов для стандартных ошибок: Error ,
// SyntaxError , ReferenceError , TypeError и другие. Можно использовать и их для
// создания объектов ошибки.

// Для встроенных ошибок (не для любых объектов, только для ошибок), свойство name –
// это в точности имя конструктора. А свойство message берётся из аргумента.

let error = new Error(" Ого, ошибка! o_O");
alert(error.name); // Error
alert(error.message); // Ого, ошибка! o_O

// В нашем случае отсутствие свойства name – это ошибка, ведь пользователи должны
// иметь имена.
// Сгенерируем её:

let json2 = '{ "age": 30 }';
try{
    let user2 = JSON.parse(json2);
    if(!user2.name){
        throw new SyntaxError("Данные некорректны: нет имени");
    }
    alert(user2.name);
}catch(e){
    alert( "JSON Error: " + e.message );
}

// В примере выше мы использовали try..catch для обработки некорректных данных. А
// что, если в блоке try {...} возникнет другая неожиданная ошибка? Например,
// программная (неопределённая переменная) или какая-то ещё, а не ошибка, связанная с
// некорректными данными.

// Блок catch должен обрабатывать только те ошибки, которые ему известны, и
// «пробрасывать» все остальные.
// Техника «проброс исключения» выглядит так:
// 1. Блок catch получает все ошибки.
// 2. В блоке catch(err) {...} мы анализируем объект ошибки err .
// 3. Если мы не знаем как её обработать, тогда делаем throw err .
// В коде ниже мы используем проброс исключения, catch обрабатывает только
// SyntaxError :

let json3 = '{ "age": 30 }'; // данные неполны
try {
    let user3 = JSON.parse(json3);
    if (!user3.name) {
        throw new SyntaxError("Данные неполны: нет имени");
    }
    blabla(); // неожиданная ошибка
    alert( user3.name );
} catch(e) {
if (e.name == "SyntaxError") {
    alert( "JSON Error: " + e.message );
} else {
    throw e; // проброс (*)
    }
}


// Ошибка в строке (*) из блока catch «выпадает наружу» и может быть поймана другой
// внешней конструкцией try..catch (если есть), или «убьёт» скрипт.
// Таким образом, блок catch фактически обрабатывает только те ошибки, с которыми он
// знает, как справляться, и пропускает остальные.

function readData() {
    let json3 = '{ "age": 30 }'; // данные неполны
    try {
        let user3 = JSON.parse(json3);
        if (!user3.name) {
            throw new SyntaxError("Данные неполны: нет имени");
        }
        blabla(); // неожиданная ошибка
        alert( user3.name );
    } catch(e) {
    if (e.name == "SyntaxError") {
        alert( "JSON Error: " + e.message );
    } else {
        throw e; // проброс (*)
        }
    }
}

try {
    readData();
    } catch (e) {
    alert( "Внешний catch поймал: " + e ); // поймал!
}
    
// Здесь readData знает только, как обработать SyntaxError , тогда как внешний блок
// try..catch знает, как обработать всё.

// Конструкция try..catch может содержать ещё одну секцию: finally .
// Если секция есть, то она выполняется в любом случае:
// после try , если не было ошибок,
// после catch , если ошибки были.
// Расширенный синтаксис выглядит следующим образом:

try {
    //... пробуем выполнить код...
} catch(e) {
    //... обрабатываем ошибки ...
} finally {
    //... выполняем всегда ...
}

// Секцию finally часто используют, когда мы начали что-то делать и хотим завершить это
// вне зависимости от того, будет ошибка или нет.
// Например, мы хотим измерить время, которое занимает функция чисел Фибоначчи
// fib(n) . Естественно, мы можем начать измерения до того, как функция начнёт
// выполняться и закончить после. Но что делать, если при вызове функции возникла
// ошибка? В частности, реализация fib(n) в коде ниже возвращает ошибку для
// отрицательных и для нецелых чисел.
// Секция finally отлично подходит для завершения измерений несмотря ни на что.
// Здесь finally гарантирует, что время будет измерено корректно в обеих ситуациях – и в
// случае успешного завершения fib и в случае ошибки
    
let num = +prompt("Введите положительное целое число?", 35)
let diff, result;

function fib(n) {
    if (n < 0 || Math.trunc(n) != n) {
        throw new Error("Должно быть целое неотрицательное число");
    }
    return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

let start = Date.now();
try {
    result = fib(num);
} catch (e) {
    result = 0;
} finally {
    diff = Date.now() - start;
}
alert(result || "возникла ошибка");
alert( `Выполнение заняло ${diff}ms` );

