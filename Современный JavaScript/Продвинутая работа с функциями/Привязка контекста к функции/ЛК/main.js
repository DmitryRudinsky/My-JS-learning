// Мы уже видели примеры потери this . Как только метод передаётся отдельно от объекта
// – this теряется.

// Решение 1: сделать функцию-обёртку
// Самый простой вариант решения – это обернуть вызов в анонимную функцию, создав
// замыкание:

let user = {
    firstName: "Вася",
    sayHi() {
        alert(`Привет, ${this.firstName}!`);
    }
};
setTimeout(function() {
user.sayHi(); // Привет, Вася!
}, 1000);


// Решение 2: привязать контекст с помощью bind
// В современном JavaScript у функций есть встроенный метод bind, который позволяет
// зафиксировать this .
// Базовый синтаксис bind :
// let boundFunc = func.bind(context);

// Результатом вызова func.bind(context) является особый «экзотический объект»
// (термин взят из спецификации), который вызывается как функция и прозрачно передаёт
// вызов в func , при этом устанавливая this=context .
// Другими словами, вызов boundFunc подобен вызову func с фиксированным this .

let user2 = {
    firstName: "Вася"
};
function func() {
    alert(this.firstName);
}
let funcUser = func.bind(user2);
funcUser(); // Вася
    
