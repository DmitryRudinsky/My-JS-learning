// Существует ещё один вариант объявлять функции. Он используется крайне редко, но
// иногда другого решения не найти.

// let func = new Function([arg1, arg2, ...argN], functionBody);

// Функция создаётся с заданными аргументами arg1...argN и телом functionBody .
// Это проще понять на конкретном примере. Здесь объявлена функция с двумя
// аргументами:

let sum = new Function('a', 'b', 'return a + b');
alert(sum(1, 2)) //3

// Главное отличие от других способов объявления функции, которые были рассмотрены
// ранее, заключается в том, что функция создаётся полностью «на лету» из строки,
// переданной во время выполнения.
// Все предыдущие объявления требовали от нас, программистов, писать объявление
// функции в скрипте.
// Но new Function позволяет превратить любую строку в функцию.

// Обычно функция запоминает, где родилась, в специальном свойстве [[Environment]] .
// Это ссылка на лексическое окружение (Lexical Environment), в котором она создана (мы
// разбирали это в главе Замыкание).
// Но когда функция создаётся с использованием new Function , в её [[Environment]]
// записывается ссылка не на внешнее лексическое окружение, в котором она была создана,
// а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным.

function getFunc() {
    let value = "test";
    let func = new Function('alert(value)');
    return func;
}
getFunc()(); // ошибка: value не определено

function getFunc2() {
    let value = "test";
    let func = function() { alert(value); };
    return func;
}
getFunc2()(); // "test", из лексического окружения функции getFunc

// Если бы new Function имела доступ к внешним переменным, при этом были бы
// проблемы с минификаторами.