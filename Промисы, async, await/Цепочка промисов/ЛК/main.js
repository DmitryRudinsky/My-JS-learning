// Давайте вернёмся к ситуации из главы Введение: колбэки: у нас есть последовательность
// асинхронных задач, которые должны быть выполнены одна за другой. Например, речь
// может идти о загрузке скриптов. Как же грамотно реализовать это в коде?
// Промисы предоставляют несколько способов решения подобной задачи.
// В этой главе мы разберём цепочку промисов.

// Она выглядит вот так:

new Promise(function(resolve, reject) {

    setTimeout(() => resolve(1), 1000); // (*)
  
  }).then(function(result) { // (**)
  
    alert(result); // 1
    return result * 2;
  
  }).then(function(result) { // (***)
  
    alert(result); // 2
    return result * 2;
  
  }).then(function(result) {

    alert(result); // 4
    return result * 2;
});

// Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков .then.

// Поток выполнения такой:

// Начальный промис успешно выполняется через 1 секунду (*),
// Затем вызывается обработчик в .then (**).
// Возвращаемое им значение передаётся дальше в следующий обработчик .then (***)
// …и так далее.
// В итоге результат передаётся по цепочке обработчиков, и мы видим несколько alert подряд, которые выводят: 1 → 2 → 4.

