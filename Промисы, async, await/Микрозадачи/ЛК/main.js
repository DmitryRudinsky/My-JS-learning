'Обработчики промисов .then / .catch / .finally всегда асинхронны.'
'Даже когда промис сразу же выполнен, код в строках ниже .then / .catch / .finally'
'будет запущен до этих обработчиков.'
'Пример:'

let promise = Promise.resolve("Перый привет");
promise.then(console.log);
console.log("Второй привет")

let promise2 = Promise.resolve();
promise2.then(() => console.log("Третий привет"));
console.log("Четвёртный привет");

/*
Второй привет
Четвёртный привет
Перый привет
Третий привет
*/

'Если вы запустите его, сначала вы увидите код выполнен , а потом промис выполнен.'
'Это странно, потому что промис определённо был выполнен с самого начала.'

//Очередь микрозадач

'Асинхронные задачи требуют правильного управления. Для этого стандарт'
'предусматривает внутреннюю очередь PromiseJobs , более известную как «очередь'
'микрозадач (microtask queue)» (термин V8).'
'Как сказано в спецификации:'
'Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в'
'очередь первыми, выполняются тоже первыми.'
'Выполнение задачи происходит только в том случае, если ничего больше не запущено.'
'Или, проще говоря, когда промис выполнен, его обработчики .then/catch/finally'
'попадают в очередь. Они пока не выполняются. Движок JavaScript берёт задачу из'
'очереди и выполняет её, когда он освободится от выполнения текущего кода.'



'Обработчики промисов всегда проходят через эту внутреннюю очередь.'
'Если есть цепочка с несколькими .then/catch/finally , то каждый из них выполняется'
'асинхронно. То есть сначала ставится в очередь, а потом выполняется, когда выполнение'
'текущего кода завершено и добавленные ранее в очередь обработчики выполнены.'
'Но что если порядок имеет значение для нас? Как мы можем вывести код выполнен'
'после промис выполнен ?'

'Легко, используя .then :'
Promise.resolve()
    .then(() => console.log("Первый привет"))
    .then(() => console.log("Второй привет"))
    .then(() => console.log("Третий привет"))
    .then(() => console.log("Четвёртый привет"))

/*
Первый привет
Второй привет
Третий привет
Четвёртый привет
*/

//Стоит заметить, что порядок всех задач будет таким:
/*
Второй привет - первый console.log
Четвёртный привет - второй console.log

Console.log из промисов:
Перый привет
Третий привет
Первый привет
Второй привет
Третий привет
Четвёртый привет
*/




//Необработанные ошибки

'Теперь мы можем описать, как именно JavaScript понимает, что ошибка не обработана.'
'"Необработанная ошибка" возникает в случае, если ошибка промиса не'
'обрабатывается в конце очереди микрозадач.'

'Обычно, если мы ожидаем ошибку, мы добавляем .catch в конец цепочки промисов,'
'чтобы обработать её:'

let promiseErr = Promise.reject(new Error("Ошибка в промисе!"));
promiseErr.catch(err => alert('поймана!'));


window.addEventListener('unhandledrejection', event => {
  alert(event.reason);
});


'…Но если мы забудем добавить .catch, то, когда очередь микрозадач опустеет, движок сгенерирует событие:'

let promiseErr2 = Promise.reject(new Error("Ошибка в промисе!"));

// Ошибка в промисе!
window.addEventListener('unhandledrejection', event => alert(event.reason));


'А что, если мы поймаем ошибку, но позже? Вот так:'
let promiseErr3 = Promise.reject(new Error("Ошибка в промисе!"));

setTimeout(() => promiseErr3.catch(err => alert('поймана')), 1000);

// Ошибка в промисе!
window.addEventListener('unhandledrejection', event => alert(event.reason));


'Теперь, при запуске, мы сначала увидим «Ошибка в промисе!», а затем «поймана».'
'Если бы мы не знали про очередь микрозадач, то могли бы удивиться: «Почему сработал'
'обработчик unhandledrejection ? Мы же поймали ошибку!».'
'Но теперь мы понимаем, что событие unhandledrejection возникает, когда очередь'
'микрозадач завершена: движок проверяет все промисы и, если какой-либо из них в'
'состоянии «rejected», то генерируется это событие.'
'В примере выше .catch , добавленный в setTimeout , также срабатывает, но позже,'
'уже после возникновения unhandledrejection , так что это ни на что не влияет.'


