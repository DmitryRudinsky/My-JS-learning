// Многие действия в JavaScript асинхронные.
// Например, рассмотрим функцию loadScript(src) :

function loadScript(src){
    let script = document.createElement('script');
    script.src = src;
    document.head.append(script);
}

// Эта функция загружает на страницу новый скрипт. Когда в тело документа добавится
// конструкция <script src="…"> , браузер загрузит скрипт и выполнит его.
// Вот пример использования этой функции:

/*
loadScript('/my/script.js');
код, написанный после вызова функции loadScript,
не будет дожидаться полной загрузки скрипта
...
*/

// Такие функции называют «асинхронными», потому что действие (загрузка скрипта) будет
// завершено не сейчас, а потом.

// Если после вызова loadScript(…) есть какой-то код, то он не будет ждать, пока скрипт
// загрузится.

// Мы хотели бы использовать новый скрипт, как только он будет загружен. Скажем, он
// объявляет новую функцию, которую мы хотим выполнить.
// Но если мы просто вызовем эту функцию после loadScript(…) , у нас ничего не выйдет


// Действительно, ведь у браузера не было времени загрузить скрипт. Сейчас функция
// loadScript никак не позволяет отследить момент загрузки. Скрипт загружается, а потом
// выполняется. Но нам нужно точно знать, когда это произойдёт, чтобы использовать
// функции и переменные из этого скрипта.
// Давайте передадим функцию callback вторым аргументом в loadScript , чтобы
// вызвать её, когда скрипт загрузится

function loadScript2(src, callback) {
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => callback(script);
    document.head.append(script);
}

// Теперь, если мы хотим вызвать функцию из скрипта, нужно делать это в колбэке:

loadScript2('/my/script.js', function() {
    // эта функция вызовется после того, когда загрузится скрипт
    newFunction(); // теперь всё работает
    //...
});
    

// Смысл такой: вторым аргументом передаётся функция (обычно анонимная), которая
// выполняется по завершении действия.
// Возьмём для примера реальный скрипт с библиотекой функций:

function loadScript3(src, callback) {
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => callback(script);
    document.head.append(script);
}
  
loadScript3('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
    alert(`Здорово, скрипт ${script.src} загрузился`);
    alert( _ ); // функция, объявленная в загруженном скрипте
});

// Такое написание называют асинхронным программированием с использованием колбэков.
// В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент
// callback — функция, которая будет вызвана по завершению асинхронного действия.
// Мы поступили похожим образом в loadScript , но это, конечно, распространённый
// подход.


// Перехват ошибок

// В примерах выше мы не думали об ошибках. А что если загрузить скрипт не удалось?
// Колбэк должен уметь реагировать на возможные проблемы.
// Ниже улучшенная версия loadScript , которая умеет отслеживать ошибки загрузки:

