'Обычные функции возвращают только одно-единственное значение (или ничего).'

'Генераторы могут порождать (yield) множество значений одно за другим, по мере'
'необходимости. Генераторы отлично работают с перебираемыми объектами и позволяют'
'легко создавать потоки данных.'


//Функция-генератор

'Для объявления генератора используется специальная синтаксическая конструкция:'
'function* , которая называется «функция-генератор».'

'Функции-генераторы ведут себя не так, как обычные. Когда такая функция вызвана, она не'
'выполняет свой код. Вместо этого она возвращает специальный объект, так называемый'
'«генератор», для управления её выполнением.'

'Основным методом генератора является next() . При вызове он запускает выполнение'
'кода до ближайшей инструкции yield <значение> (значение может отсутствовать, в'
'этом случае оно предполагается равным undefined ). По достижении yield'

'выполнение функции приостанавливается, а соответствующее значение – возвращается'
'во внешний код:'
'Результатом метода next() всегда является объект с двумя свойствами:'
'value : значение из yield .'
'done : true , если выполнение функции завершено, иначе false .'
'Например, здесь мы создаём генератор и получаем первое из возвращаемых им значений:'

function* generateSequence(){
    yield 1;
    yield 2;
    return 3;
}

let generator = generateSequence();
let one = generator.next();
console.log(one); // { value: 1, done: false }
console.log(JSON.stringify(one)); // {"value":1,"done":false}
let two = generator.next();
console.log(JSON.stringify(two)); // {value: 2, done: false}

'И, наконец, последний вызов завершит выполнение функции и вернёт результат return:'

let three = generator.next();
console.log(JSON.stringify(three))//{"value":3,"done":true}

'Сейчас генератор полностью выполнен. Мы можем увидеть это по свойству done:true и'
'обработать value:3 как окончательный результат.'
'Новые вызовы generator.next() больше не имеют смысла. Впрочем, если они и будут,'
'то не вызовут ошибки, но будут возвращать один и тот же объект: {done: true} .'


//Перебор генераторов

'Как вы, наверное, уже догадались по наличию метода next() , генераторы являются'
'перебираемыми объектами.'
'Возвращаемые ими значения можно перебирать через for...of :'

let generator2 = generateSequence();

for(let value of generator2){
    console.log(value);
    // 1
    // 2
}

'Выглядит гораздо красивее, чем использование .next().value , верно?'
'…Но обратите внимание: пример выше выводит значение 1 , затем 2 . Значение 3'
'выведено не будет!'
'Это из-за того, что перебор через for..of игнорирует последнее значение, при котором'
'done: true . Поэтому, если мы хотим, чтобы были все значения при переборе через'
'for..of , то надо возвращать их через yield :'

function* generateSequenceYield(){
    yield 10;
    yield 20;
    yield 30;
}

let generatorYield = generateSequenceYield();
for(let value of generatorYield){
    console.log(value);
    //10
    //20
    //30
}

'Так как генераторы являются перебираемыми объектами, мы можем использовать всю'
'связанную с ними функциональность, например оператор расширения ... :'

let sequence = [0, ...generateSequenceYield()];
console.log(sequence);

'В коде выше ...generateSequence() превращает перебираемый объект-генератор в'
'массив элементов (подробнее ознакомиться с оператором расширения можно в главе'
'Остаточные параметры и оператор расширения)'


//Использование генераторов для перебираемых объектов

let range = {
    from: 1,
    to: 6,
    *[Symbol.iterator](){
        for(let value = this.from; value < this.to; value++){
            yield value
        }
    }
};

console.log(...range) //1 2 3 4 5

'Это работает, потому что range[Symbol.iterator]() теперь возвращает генератор, и'
'его методы – в точности то, что ожидает for..of :'
'у него есть метод .next()'
'который возвращает значения в виде {value: ..., done: true/false}'
'Это не совпадение, конечно. Генераторы были добавлены в язык JavaScript, в частности, с'
'целью упростить создание перебираемых объектов.'
'Вариант с генератором намного короче, чем исходный вариант перебираемого range , и'
'сохраняет те же функциональные возможности.'


//Композиция генераторов


'Композиция генераторов – это особенная возможность генераторов, которая позволяет'
'прозрачно «встраивать» генераторы друг в друга.'
'Например, у нас есть функция для генерации последовательности чисел:'

function* generateSequenceNew(start, end) {
    for (let i = start; i <= end; i++) yield i;
}

'Мы хотели бы использовать её при генерации более сложной последовательности:'
'сначала цифры 0..9 (с кодами символов 48…57)'
'за которыми следуют буквы в верхнем регистре A..Z (коды символов 65…90)'
'за которыми следуют буквы алфавита a..z (коды символов 97…122)'
'Мы можем использовать такую последовательность для генерации паролей, выбирать'
'символы из неё (может быть, ещё добавить символы пунктуации), но сначала её нужно'
'сгенерировать.'
'В обычной функции, чтобы объединить результаты из нескольких других функций, мы'
'вызываем их, сохраняем промежуточные результаты, а затем в конце их объединяем.'
'Для генераторов есть особый синтаксис yield* , который позволяет «вкладывать»'
'генераторы один в другой (осуществлять их композицию).'
'Вот генератор с композицией:'

function* generatePasswordCodes() {
    // 0..9
    yield* generateSequenceNew(48, 57);
    // A..Z
    yield* generateSequenceNew(65, 90);
    // a..z
    yield* generateSequenceNew(97, 122);
}
  
let str1 = '';
  
for(let code of generatePasswordCodes()) {
    str1 += String.fromCharCode(code);
}

console.log(str1);

'Директива yield* делегирует выполнение другому генератору. Этот термин означает,'
'что yield* gen перебирает генератор gen и прозрачно направляет его вывод наружу.'
'Как если бы значения были сгенерированы внешним генератором.'
'Результат – такой же, как если бы мы встроили код из вложенных генераторов:'

function* generatorAlphaNum(){
    for(let i = 48; i <= 57; i++) yield i;
    for(let i = 65; i <= 90; i++) yield i;
    for(let i = 97; i <= 122; i++) yield i;
}

let str2 = '';
for(let code of generatorAlphaNum()){
    str2 += String.fromCharCode(code);
}
console.log(str2);

console.log(str1 === str2);


//yield – дорога в обе стороны

'До этого момента генераторы сильно напоминали перебираемые объекты, со специальным'
'синтаксисом для генерации значений. Но на самом деле они намного мощнее и гибче.'
'Всё дело в том, что yield – дорога в обе стороны: он не только возвращает результат'
'наружу, но и может передавать значение извне в генератор.'
'Чтобы это сделать, нам нужно вызвать generator.next(arg) с аргументом. Этот'
'аргумент становится результатом yield .'
'Продемонстрируем это на примере:'

function* gen(){
    // Передаём вопрос во внешний код и ожидаем ответа
    let result = yield "2 + 2 = ?";
    console.log(result);
}

let generatorSide = gen();
let question = generatorSide.next().value; // <-- yield возвращает значение
console.log(question);
generatorSide.next(4); // --> передаём результат в генератор


'1. Первый вызов generator.next() – всегда без аргумента, он начинает выполнение и'
'возвращает результат первого yield "2+2=?" . На этой точке генератор'
'приостанавливает выполнение.'
'2. Затем, как показано на картинке выше, результат yield переходит во внешний код в'
'переменную question .'
'3. При generator.next(4) выполнение генератора возобновляется, а 4 выходит из'
'присваивания как результат: let result = 4 .'
'Обратите внимание, что внешний код не обязан немедленно вызывать next(4) . Ему'
'может потребоваться время. Это не проблема, генератор подождёт.'

'Чтобы сделать происходящее более очевидным, вот ещё один пример с большим количеством вызовов:'

function* gen2() {
    let ask1 = yield "2 + 2 = ?";
    console.log(ask1);
    let ask2 = yield "3 * 3 = ?";
    console.log(ask2);
}

let generatorSide2 = gen2();
console.log(generatorSide2.next().value);
console.log(generatorSide2.next(4).value);
console.log(generatorSide2.next(9).value);