// Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал
// времени. Это называется «планирование вызова».
// Для этого существуют два метода:
//      setTimeout позволяет вызвать функцию один раз через определённый интервал
// времени.
//      setInterval позволяет вызывать функцию регулярно, повторяя вызов через
// определённый интервал времени.


// Синтаксис
// let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)

// Параметры:
//    func|code
//        Функция или строка кода для выполнения. Обычно это функция. По историческим
//        причинам можно передать и строку кода, но это не рекомендуется.

//     delay
//        Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.

//     arg1 , arg2 …
//        Аргументы, передаваемые в функцию (не поддерживается в IE9-)


// Например, данный код вызывает sayHi() спустя одну секунду:

function sayHi(){
    alert('sayHi');
};

setTimeout(sayHi, 1000);

// С аргументами

function sayHi2(phrase, who){
    alert(`${phrase}, ${who}`);
}

setTimeout(sayHi2, 2000, "Privet", "Drug"); //Privet, Drug


// Вызов setTimeout возвращает «идентификатор таймера» timerId , который можно
// использовать для отмены дальнейшего выполнения.
// Синтаксис для отмены:
// let timerId = setTimeout(...);
// clearTimeout(timerId);


// Метод setInterval имеет такой же синтаксис как setTimeout 


// Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод
// прекращается:

let timerId = setInterval(() => alert('tick'), 2000);
// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);

