/*
Это аналогия из реальной жизни для ситуаций, с которыми мы часто сталкиваемся в
программировании:
1. Есть «создающий» код, который делает что-то, что занимает время. Например,
загружает данные по сети. В нашей аналогии это – «певец».
2. Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда
он будет готов. Он может быть необходим более чем одной функции. Это – «фанаты».
3. Promise (по англ. promise , будем называть такой объект «промис») – это
специальный объект в JavaScript, который связывает «создающий» и «потребляющий»
коды вместе. В терминах нашей аналогии – это «список для подписки». «Создающий»
код может выполняться сколько потребуется, чтобы получить результат, а промис делает
результат доступным для кода, который подписан на него, когда результат готов.
Аналогия не совсем точна, потому что объект Promise в JavaScript гораздо сложнее
простого списка подписок: он обладает дополнительными возможностями и
ограничениями. Но для начала и такая аналогия хороша.
*/

// Синтаксис создания Promise:
let promise = new Promise(function(resolve, reject) {
    // функция-исполнитель (executor)
    // "певец"
});

// Функция, переданная в конструкцию new Promise , называется исполнитель (executor).
// Когда Promise создаётся, она запускается автоматически. Она должна содержать
// «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии:
// исполнитель – это «певец».
// Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript.
// Наш код – только внутри исполнителя.
// Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих
// колбэков:
// resolve(value) — если работа завершилась успешно, с результатом value .
// reject(error) — если произошла ошибка, error – объект ошибки.
// Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем
// вызвать resolve или reject .



// У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:

// state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve 
// или на "rejected" («выполнено с ошибкой») при вызове reject.
// result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) 
// или на error при вызове reject(error).
// Так что исполнитель по итогу переводит promise в одно из двух состояний

// Ниже пример конструктора Promise и простого исполнителя с кодом, дающим результат с задержкой (через setTimeout):

let promiseTrue = new Promise(function(resolve, reject){
    //эта функция выполнится автоматически, при вызове new Promise
    //через 1 секунду сигнализировать, что задача выполнена с результатом "done"
    setTimeout(() => resolve("done"), 1000);
})

// Мы можем наблюдать две вещи, запустив код выше:
// Функция-исполнитель запускается сразу же при вызове new Promise.
// Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript, поэтому
// нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности.


// Это был пример успешно выполненной задачи, в результате мы получили «успешно выполненный» промис.
// А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой

let promiseFalse = new Promise(function(resolve, reject){
    // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
    setTimeout(() => reject(new Error("You are lame")), 1000);
})


// Подведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем
// вызывает resolve или reject, чтобы изменить состояние соответствующего Promise.

// Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса «в ожидании».





// Потребители: then, catch
// Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и
// функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-
// потребители могут быть зарегистрированы (подписаны) с помощью методов .then и .catch.


// then
// Наиболее важный и фундаментальный метод – .then.
// Синтаксис:
/*
promise.then(
    function(result) { обработает успешное выполнение  },
    function(error) {обработает ошибку}
)
*/

// Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», 
// и получает результат.
// Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.
// Например, вот реакция на успешно выполненный промис:

promiseTrue = new Promise(function(resolve, reject){
    setTimeout(() => resolve("done"), 1000);
})

promiseTrue.then(
    result => alert(result),
    error => alert(error)
);

// Выполнилась первая функция.
// А в случае ошибки в промисе – выполнится вторая


/*
catch
 Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента:
.then(null, errorHandlingFunction). 
Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает то же самое:
*/

let promiseError = new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error("Ошибка!")), 1000);
});
  
// .catch(f) это то же самое, что promise.then(null, f)
promiseError.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду


/*
finally
По аналогии с блоком finally из обычного try {...} catch {...} , у промисов
также есть метод finally.

Вызов .finally(f) похож на .then(f, f) , в том смысле, что f выполнится в любом
случае, когда промис завершится: успешно или с ошибкой.

finally хорошо подходит для очистки, например остановки индикатора загрузки, его
ведь нужно остановить вне зависимости от результата.

Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.

Например, остановка индикаторов загрузки, закрытие больше не нужных соединений и т.д.

Код может выглядеть следующим образом:

new Promise((resolve, reject) => {
  //сделать что-то, что займёт время, и после вызвать resolve или может reject 
})
// выполнится, когда промис завершится, независимо от того, успешно или нет
.finally(() => остановить индикатор загрузки)
// таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
.then(result => показать результат, err => показать ошибку)

*/