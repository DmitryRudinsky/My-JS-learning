'Цепочки промисов отлично подходят для перехвата ошибок. Если промис завершается с'
'ошибкой, то управление переходит в ближайший обработчик ошибок. На практике это'
'очень удобно.'
'Например, в представленном ниже примере для fetch указана неправильная ссылка'
'(сайт не существует), и .catch перехватывает ошибку:'


fetch('https://no-such-server.blabla') // ошибка
  .then(response => response.json())
  .catch(err => alert(err)) // TypeError: failed to fetch (текст может отличаться)


'Как видно, .catch не обязательно должен быть сразу после ошибки, он может быть'
'далее, после одного или даже нескольких .then'
'Или, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON.'
'Самый лёгкий путь перехватить все ошибки – это добавить .catch в конец цепочки:'


fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise((resolve, reject) => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);
    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
  .catch(error => alert(error.message));


'Если все в порядке, то такой .catch вообще не выполнится. Но если любой из промисов будет отклонён'
'(проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.'



//Пробрасывание ошибок

'Как мы уже заметили, .catch ведёт себя как try..catch . Мы можем иметь столько'
'обработчиков .then , сколько мы хотим, и затем использовать один .catch в конце,'
'чтобы перехватить ошибки из всех обработчиков.'
'В обычном try..catch мы можем проанализировать ошибку и повторно пробросить'
'дальше, если не можем её обработать. То же самое возможно для промисов.'
'Если мы пробросим ( throw ) ошибку внутри блока .catch , то управление перейдёт к'
'следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим'
'работу обработчика нормально, то продолжит работу ближайший успешный обработчик'
'.then .'
'В примере ниже .catch успешно обрабатывает ошибку:'

// the execution: catch -> then
new Promise((resolve, reject) => {

    throw new Error("Ошибка!");
  
  }).catch(function(error) {
  
    alert("Ошибка обработана, продолжить работу");
  
  }).then(() => alert("Управление перейдёт в следующий then"));


'Здесь блок .catch завершается нормально. Поэтому вызывается следующий успешный'
'обработчик .then .'

'В примере ниже мы видим другую ситуацию с блоком .catch . Обработчик (*)'
'перехватывает ошибку и не может обработать её (например, он знает как обработать'
'только URIError ), поэтому ошибка пробрасывается далее:'

// the execution: catch -> catch -> then
new Promise((resolve, reject) => {

    throw new Error("Ошибка!");
  
  }).catch(function(error) { // (*)
  
    if (error instanceof URIError) {
      // обрабатываем ошибку
    } else {
      alert("Не могу обработать ошибку");
  
      throw error; // пробрасывает эту или другую ошибку в следующий catch
    }
  
  }).then(function() {
    /* не выполнится */
  }).catch(error => { // (**)
  
    alert(`Неизвестная ошибка: ${error}`);
    // ничего не возвращаем => выполнение продолжается в нормальном режиме
  
  });



