'Существует специальный синтаксис для работы с промисами, который называется «async/await». '
'Он удивительно прост для понимания и использования.'


//Асинхронные функции
'Начнём с ключевого слова async . Оно ставится перед функцией, вот так:'
async function f1(){
  return 1;
}

'У слова async один простой смысл: эта функция всегда возвращает промис. '
'Значения других типов оборачиваются в завершившийся успешно промис автоматически.'

'Например, эта функция возвратит выполненный промис с результатом 1:'

f1().then(console.log);
//1

'Так что ключевое слово async перед функцией гарантирует, что эта функция в любом'
'случае вернёт промис. Согласитесь, достаточно просто? Но это ещё не всё. Есть другое'
'ключевое слово – await , которое можно использовать только внутри async -функций'

//Await

// работает только внутри async–функций
//let value = await promise;

'Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис'
'справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода'
'продолжится.'
'В этом примере промис успешно выполнится через 1 секунду:'

async function f2(){
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Прошла одна секунда"), 1000)
  });
  let result = await promise;
  console.log(result);
}

f2(); //Прошла одна секунда

'В данном примере выполнение функции остановится на строке (*) до тех пор, пока'
'промис не выполнится. Это произойдёт через секунду после запуска функции. После чего'
'в переменную result будет записан результат выполнения промиса, и браузер отобразит'
'alert-окно «готово!».'
'Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения'
'промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок'
'может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и'
'т.п.'
'По сути, это просто «синтаксический сахар» для получения результата промиса, более'
'наглядный, чем promise.then .'

/*
Если мы попробуем использовать await внутри функции, объявленной без async, получим синтаксическую ошибку:
function f() {
  let promise = Promise.resolve(1);
  let result = await promise; // SyntaxError
}
Ошибки не будет, если мы укажем ключевое слово async перед объявлением функции. 
Как было сказано раньше, await можно использовать только внутри async–функций.
*/

'Пример:'

async function showAvatar(){
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();

  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();

  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);

  await new Promise((resolve, reject) => setTimeout(resolve, 3000));
  img.remove();
  return githubUser;
}


'Программисты, узнав об await , часто пытаются использовать эту возможность на'
'верхнем уровне вложенности (вне тела функции). Но из-за того, что await работает'
'только внутри async –функций, так сделать не получится:'

'Можно обернуть этот код в анонимную async–функцию, тогда всё заработает:'

(async () => {
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
})();


/*
Асинхронные методы классов

Для объявления асинхронного метода достаточно написать async перед именем:

class Waiter {
  async wait() {
    return await Promise.resolve(1);
  }
}

new Waiter()
  .wait()
  .then(alert); // 1

Как и в случае с асинхронными функциями, такой метод гарантированно возвращает
промис, и в его теле можно использовать await .

*/


//Обработка ошибок

'Когда промис завершается успешно, await promise возвращает результат. Когда'
'завершается с ошибкой – будет выброшено исключение. Как если бы на этом месте'
'находилось выражение throw .'

'Такой код:'

async function f() {
  await Promise.reject(new Error("Упс!"));
}

'Делает то же самое, что и такой:'

async function f() {
  throw new Error("Упс!");
}

'Но есть отличие: на практике промис может завершиться с ошибкой не сразу, а через'
'некоторое время. В этом случае будет задержка, а затем await выбросит исключение.'
'Такие ошибки можно ловить, используя try..catch , как с обычным throw :'

async function fErr(){
  try{
    let response = await fetch('/no-user-here');
    let user = await response.json();
  } catch(err){
    console.log(err);
  }
}

'Если у нас нет try..catch , асинхронная функция будет возвращать завершившийся с'
'ошибкой промис (в состоянии rejected ). В этом случае мы можем использовать метод'
'.catch промиса, чтобы обработать ошибку:'

async function f() {
  let response = await fetch('http://no-such-url');
}

// f() вернёт промис в состоянии rejected
f().catch(alert); // TypeError: failed to fetch // (*)


