// Чтобы сделать range итерируемым (и позволить for..of работать с ним), нам нужно
// добавить в объект метод с именем Symbol.iterator (специальный встроенный
// Symbol , созданный как раз для этого).

    // 1.Когда цикл for..of запускается, он вызывает этот метод один раз (или выдаёт ошибку,
    // если метод не найден). Этот метод должен вернуть итератор – объект с методом
    // next .
    // 2. Дальше for..of работает только с этим возвращённым объектом.
    // 3. Когда for..of хочет получить следующее значение, он вызывает метод next() этого
    // объекта.
    // 4. Результат вызова next() должен иметь вид {done: Boolean, value: any} , где
    // done=true означает, что итерация закончена, в противном случае value содержит
    // очередное значение.
    

let range = {
    from: 1,
    to: 5
};
range[Symbol.iterator] = function() {
    // ...она возвращает объект итератора:
    // 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения
    return {
        current: this.from,
        last: this.to,
        // 3. next() вызывается на каждой итерации цикла for..of
        next() {
            // 4. он должен вернуть значение в виде объекта {done:.., value :...}
            if (this.current <= this.last) {
                return { done: false, value: this.current++ };
            } else {
                return { done: true };
            }
        }
    };
};
// теперь работает!
for (let num of range) {
    alert(num); // 1, затем 2, 3, 4, 5
}
// 1. вызов for..of сначала вызывает эту функцию

// Таким образом, итератор отделён от самого итерируемого объекта.
// Технически мы можем объединить их и использовать сам range как итератор, чтобы
// упростить код.
// Например, вот так


range = {
    from: 1,
    to: 5,
    [Symbol.iterator]() {
        this.current = this.from;
        return this;
    },
    next(){
        if(this.current <= this.to){
            return{done: false, value: this.current++};
        }else{
            return{done:true}
        }
    }
}
for(let num of range){
    alert(num);
}

// Строка – перебираемый объект
// Среди встроенных перебираемых объектов наиболее широко используются массивы и
// строки.
// Для строки for..of перебирает символы:

for (let char of "test") {
    // срабатывает 4 раза: по одному для каждого символа
    alert( char ); // t, затем e, затем s, затем t
}
    


// Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator ,
// как было описано выше.
// Псевдомассивы – это объекты, у которых есть индексы и свойство length , то есть, они
// выглядят как массивы.


// Есть универсальный метод Array.from  , который принимает итерируемый объект или
// псевдомассив и делает из него «настоящий» Array . После этого мы уже можем
// использовать методы массивов.


let arrayLike = {
    0: "Hello",
    1: "World",
    length: 2
}

let arr = Array.from(arrayLike);
alert(arr.pop()); // World (метод работает)

// Полный синтаксис Array.from позволяет указать необязательную
// «трансформирующую» функцию:

// Array.from(obj[mapFn, thisArg])

// Необязательный второй аргумент может быть функцией, которая будет применена к
// каждому элементу перед добавлением в массив, а thisArg позволяет установить this
// для этой функции.

arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
