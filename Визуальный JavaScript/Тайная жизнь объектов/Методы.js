"Методы - это не что иное, как свойства, которые содержат функциональные значения."
"Например:"

let rabbit = {};
rabbit.speak = function(line){
    console.log(`Rabbit says: "${line}"`);
};

rabbit.speak("I am tired...");

"Обычно метод должен что-то делать с объектом, для которого он был вызван."
"Когда функция вызывается как метод, она выглядит как свойство и вызывается сразу, как в object.method():"
"в её теле существует привязка, называемая this, автоматически указывающая на объект, для которого была вызвана функция"

function speak(line){
    console.log(`${this.type} Rabbit says: "${line}"`);
}

let whiteRabbit = {type: "White", speak};
let HungryRabbit = {type: "Hungry", speak};

whiteRabbit.speak("I am white, i am proud!");
HungryRabbit.speak("I will eat your mother");


"Привязку this можно представить как дополнительный параметр, передаваемый другим способом."
"Если вы хотите передать его явно, то можете использовать метод функции call, который принимает значение this"
"в качестве первого аргумента и обрабатывает остальные аргументы, как обычные параметры."

speak.call(whiteRabbit, "Dye, my darling");

"Поскольку у каждой функции есть своя привязка this, значение которой зависит от способа её вызова,"
"вы не можете ссылаться на this в области видимости обычной функции, определённой с помощью ключевого слова function"

"Стрелочные функции ведут себя иначе: у них нет собственных объектов this, но они могут видеть привязку this, принадлежащую"
"области видимости, внутри которой они находятся. Таким образом, можно выполять что-то вроде следующего кода,"
"ссылающегося на this внутри локальной функции."

function normalize(){
    console.log(this.coords.map(n => n / this.length));
}

normalize.call({coords: [0, 2, 3], length: 5}); //[ 0, 0.4, 0.6 ]

"Если бы я написал аргумент для map, используя ключевое слово function, этот код бы не работал"