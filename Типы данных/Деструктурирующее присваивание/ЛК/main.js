// Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам
// «распаковать» массивы или объекты в кучу переменных, так как иногда они более удобны.
// Деструктуризация также прекрасно работает со сложными функциями, которые имеют
// много параметров, значений по умолчанию и так далее.

// Деструктуризация массива

let arr = ["Dmitry", "Gula"];
let [firstName, surname] = arr;
alert(firstName); //Dmitry
alert(surname); //Gula

// Теперь мы можем использовать переменные вместо элементов массива.
// Отлично смотрится в сочетании со split или другими методами, возвращающими
// массив:

[firstName, surname] = "Dmitry Gula".split(' ');
// Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не
// делает с правой частью присваивания, его задача – только скопировать нужные
// значения в переменные.

// Ненужные элементы массива также могут быть отброшены через запятую:

// второй элемент не нужен
let [firstName1, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
alert(title) //Consul

// В примере выше второй элемент массива пропускается, а третий присваивается
// переменной title , оставшиеся элементы массива также пропускаются (так как для
// них нет переменных).

// На самом деле мы можем использовать любой перебираемый объект, не только
// массивы:

let[a, b, c] = "abc";
let[one, two, three] = new Set([1, 2, 3]);

// Мы можем использовать что угодно «присваивающее» с левой стороны.
// Например, можно присвоить свойству объекта:

let user = {};
[user.name, user.surname] = "Dmitry Gula".split(" ");
alert(user.name) //Dmitry

// В предыдущей главе мы видели метод Object.entries(obj)  .
// Мы можем использовать его с деструктуризацией для цикличного перебора ключей и
// значений объекта:

let user2 = {
    name: "Jhon",
    age: 30,
}

for(let [key, value] of Object.entries(user2)){
    alert(`${key}:${value}`);
}

//то же самое и для map

let map = new Map();
map.set("Dmitry", "Gula");
map.set("Chester", "Rudinsky");

for(let [key, value] of map){
    alert(`${key}:${value}`);
}

// Остаточные параметры «…»
// Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы
// можем добавить ещё один параметр, который получает остальные значения, используя
// оператор «остаточные параметры» – троеточие ( "..." ):

let [name1, name2, ...rest] = ["Vladimir", "Putin", "Great", "President"];
alert(name1); //Vladimir
alert(name2); //Putin
for(elem of rest){
    alert(elem); //Great, President
}

// Переменная rest является массивом из оставшихся элементов. Вместо rest можно
// использовать любое другое название переменной, просто убедитесь, что перед
// переменной есть три точки и она стоит на последнем месте в деструктурирующем
// присваивании.

// Значения по умолчанию
// Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие
// значения считаются неопределёнными:

[firstName, surname] = [];
alert(firstName); // undefined
alert(surname); // undefined

// Если нам необходимо указать значения по умолчанию, то мы можем использовать = :

let [username = "Guest", usersurname = "Anon"] = ["Viper"];
alert(username); //Viper
alert(usersurname); //Anon

// Значения по умолчанию могут быть гораздо более сложными выражениями или даже
// функциями. Они выполняются, только если значения отсутствуют.
// Например, здесь мы используем функцию prompt для указания двух значений по
// умолчанию. Но она будет запущена только для отсутствующего значения:


let [name3 = prompt('name?'), surname3 = prompt('surname?')] = ["Julius"];
alert(name3); // Julius (из массива)
alert(surname3); // результат prompt




// Деструктуризация объекта

// Деструктурирующее присваивание также работает с объектами.
// Синтаксис:

// let {var1, var2} = {var1:…, var2:…}

// У нас есть существующий объект с правой стороны, который мы хотим разделить на
// переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом
// случае это список названий переменных в {...} .

let options = {
    title1: "Menu",
    width: 100,
    height: 200
};
let {title1, width, height} = options;
alert(title1); // Menu
alert(width); // 100
alert(height); // 200

// Свойства options.title , options.width и options.height присваиваются
// соответствующим переменным. Порядок не имеет значения.

// Если мы хотим присвоить свойство объекта переменной с другим названием, например,
// свойство options.width присвоить переменной w , то мы можем использовать
// двоеточие:

let {width: w, height: h, title1: t} = options;
alert(w); //100
alert(h); //200
alert(t); //Menu

// Для потенциально отсутствующих свойств мы можем установить значения по умолчанию,
// используя "=" , как здесь:

options = {
    title: "Menu"
};

let {width2 = 100, height2 = 200, title2} = options;
    
alert(title2); // Menu
alert(width2); // 100
alert(height2); // 200

// Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или
// даже функции. Они выполнятся, если значения отсутствуют.
// В коде ниже prompt запросит width , но не title :

options = {
    title: "Menu"
};
let {width4 = prompt("width?"), title4 = prompt("title?")} = options;
alert(title4); // Menu
alert(width4); // (результат prompt)

options = {
    title: "Menu"
};
let {width5: w5 = 100, height5: h5 = 200, title5} = options;
alert(title5); // Menu
alert(w5); // 100
alert(h5); // 200

// Что если в объекте больше свойств, чем у нас переменных? Можем ли мы взять
// необходимые нам, а остальные присвоить куда-нибудь?
// Можно использовать троеточие, как и для массивов. В некоторых старых браузерах (IE) это
// не поддерживается, используйте Babel для полифила.

options = {
    title: "Menu",
    height: 200,
    width: 100
};
// title = свойство с именем title
// rest = объект с остальными свойствами
let {title6, ...rest6} = options;
// сейчас title="Menu", rest={height: 200, width: 100}
alert(rest.height); // 200
alert(rest.width); // 100





// Вложенная деструктуризация

// Если объект или массив содержит другие вложенные объекты или массивы, то мы можем
// использовать более сложные шаблоны с левой стороны, чтобы извлечь более глубокие
// свойства.


let newOptions = {
    size: {
        width6: 100,
        height6: 200,
    },
    items: ["Cake", "Donut"],
    extra: true,
};

let{
    size: {
        width7,
        height7
    },
    items: [item1, item2],
    title7 = "Menu",
} = newOptions;

alert(title7); // Menu
alert(width7); // 100
alert(height7); // 200
alert(item1); // Cake
alert(item2); //Donut





// Умные параметры функций

// Мы можем передать параметры как объект, и функция немедленно деструктурирует его в
// переменные:

options = {
    title: "My Menu",
    items: ["Item1", "Item2"]
};

function showMenu({title = "Untitled", width = 200, height = 100, items = []}){
    alert(`width: ${width}, height: ${height}`); //width: 200, height: 100
    alert(`title: ${title}`); //title: My Menu
    alert(`items: ${items}`); //items: Item1,Item2
}

showMenu(options);


// Мы также можем использовать более сложное деструктурирование с вложенными
// объектами и двоеточием:

options = {
    title: "My Menu",
    items: ["Item1", "Item2"]
};

function showMenu2({
    title = "Untitled",
    width : w = 200,
    height : h = 100,
    items: [item1, item2]
}) {
    alert(`width: ${w}, height: ${h}`); //width: 200, height: 100
    alert(`title: ${title}`); //title: My Menu
    alert(`items: ${item1}, ${item2}`); //items: Item1, Item2
}

showMenu2(options)


// Полный синтаксис – такой же, как для деструктурирующего присваивания:
// function({
//     incomingProperty: varName = defaultValue
//     ...
// })

// Тогда для объекта с параметрами будет создана переменная varName для свойства с
// именем incomingProperty по умолчанию равная defaultValue .

// обратите внимание, что такое деструктурирование подразумевает, что в
// showMenu() будет обязательно передан аргумент. Если нам нужны все значения по
// умолчанию, то нам следует передать пустой объект:

showMenu({}); // ок, все значения - по умолчанию
showMenu(); // так была бы ошибка

// Мы можем исправить это, сделав {} значением по умолчанию для всего объекта
// параметров:

function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
    alert( `${title} ${width} ${height}` );
}
showMenu(); // Menu 100 200

