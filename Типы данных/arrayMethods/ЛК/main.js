// Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами.
// Умеет всё: добавлять, удалять и заменять элементы.
// arr.splice(index[, deleteCount, elem1, ..., elemN])

// Он начинает с позиции index , удаляет deleteCount элементов и вставляет elem1,
// ..., elemN на их место. Возвращает массив из удалённых элементов.

let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1);  // начиная с позиции 1, удалить 1 элемент
alert(arr); // осталось ["Я", "JavaScript"]

arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
arr.splice(0, 3, "Давай", "танцевать"); //уберем 3 первых элемента и заменим их на "Давай" "танцевать"
alert(arr) //["Давай", "танцевать", "прямо", "сейчас"]

// splice возвращает массив из удалённых элементов:

arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
let removed = arr.splice(0, 2);
alert(removed); // ["Я", "изучаю"]

// Метод splice также может вставлять элементы без удаления, для этого достаточно
// установить deleteCount в 0 

arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
arr.splice(2, 0, "сложный", "язык");
alert(arr); // "Я", "изучаю", "сложный", "язык", "JavaScript"

arr = [1, 2, 5];
// начиная с индекса -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);
alert( arr ); // 1,2,3,4,5



// slice
// Метод arr.slice намного проще, чем похожий на него arr.splice 

// arr.slice([start], [end])

// Он возвращает новый массив, в который копирует элементы, начиная с индекса start и
// до end (не включая end ). Оба индекса start и end могут быть отрицательными. В
// таком случае отсчёт будет осуществляться с конца массива.
// Это похоже на строковый метод str.slice , но вместо подстрок возвращает подмассивы.

arr = ["t", "e", "s", "t"];
alert(arr.slice(1, 3)); // "e", "s"
alert(arr.slice(-2)); // "s", "t"

// Метод arr.concat создаёт новый массив, в который копирует данные из других массивов
// и дополнительные значения.

// Его синтаксис:
// arr.concat(arg1, arg2...)
// Он принимает любое количество аргументов, которые могут быть как массивами, так и
// простыми значениями.
// В результате мы получаем новый массив, включающий в себя элементы из arr , а также
// arg1 , arg2 и так далее…


arr = [1, 2];
alert(arr.concat([3, 4])); //1, 2, 3, 4
alert(arr.concat([3, 4], [5, 6])); //1, 2, 3, 4, 5, 6
alert(arr.concat([3, 4], 5, 6)); //1, 2, 3, 4, 5, 6

// Обычно он просто копирует элементы из массивов. Другие объекты, даже если они
// выглядят как массивы, добавляются как есть:

let arrayLike = {
    0: "что-то",
    length: 1
};

alert(arr.concat(arrayLike)); //1, 2, [object Object]

// Но если объект имеет специальное свойство Symbol.isConcatSpreadable , то он
// обрабатывается concat как массив: вместо него добавляются его числовые свойства.
// Для корректной обработки в объекте должны быть числовые свойства и length :

arrayLike = {
    0: "что-то",
    1: "ещё",
    [Symbol.isConcatSpreadable]: true,
    length: 2
};

alert(arr.concat(arrayLike)); //1,2,что-то,ещё



// Метод arr.forEach  позволяет запускать функцию для каждого элемента массива.
// arr.forEach(function(item, index, array) {
//     // ... делать что-то с item
// });

["Bilbo", "Gandalf", "Nazgul"].forEach(alert); //этот код выведет на экран каждый элемент массива

["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
    alert(`${item} имеет позицию ${index} в ${array}`); //А этот вдобавок расскажет и о своей позиции в массиве
});

// indexOf/lastIndexOf и includes
// Методы arr.indexOf  , arr.lastIndexOf  и arr.includes  имеют одинаковый синтаксис и
// делают по сути то же самое, что и их строковые аналоги, но работают с элементами
// вместо символов:
// arr.indexOf(item, from) ищет item , начиная с индекса from , и возвращает
// индекс, на котором был найден искомый элемент, в противном случае -1 .
// arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
// arr.includes(item, from) – ищет item , начиная с индекса from , и возвращает
// true , если поиск успешен.

arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
alert( arr.includes(1) ); // true

// find и findIndex
// Представьте, что у нас есть массив объектов. Как нам найти объект с определённым
// условием?
// Здесь пригодится метод arr.find .
// Его синтаксис таков:

// let result = arr.find(function(item, index, array) {
//     // если true - возвращается текущий элемент и перебор прерывается
//     // если все итерации оказались ложными, возвращается undefined 
// });

// Функция вызывается по очереди для каждого элемента массива:
// item – очередной элемент.
// index – его индекс.
// array – сам массив.

// Если функция возвращает true , поиск прерывается и возвращается item . Если ничего
// не найдено, возвращается undefined .

let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);
alert(user.name); // Вася

// Метод arr.findIndex  – по сути, то же самое, но возвращает индекс, на котором был
// найден элемент, а не сам элемент, и -1 , если ничего не найдено.



// На тот случай, если найденных элементов может быть много, предусмотрен метод
// arr.filter(fn).

// Синтаксис этого метода схож с find , но filter возвращает массив из всех подходящих
// элементов:

let results = arr.filter(function(item, index, array) {
    // если true - элемент добавляется к результату, и перебор продолжается
    // возвращается пустой массив в случае, если ничего не найдено
});

users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];


let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2


// Метод arr.map является одним из наиболее полезных и часто используемых.

// Он вызывает функцию для каждого элемента массива и возвращает массив результатов
// выполнения этой функции.

let result = arr.map(function(item, index, array) {
    // возвращается новое значение вместо элемента
});

// Например, здесь мы преобразуем каждый элемент в его длину:

let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6


// sort(fn)
// Вызов arr.sort()  сортирует массив на месте, меняя в нём порядок элементов.
// Он возвращает отсортированный массив, но обычно возвращаемое значение
// игнорируется, так как изменяется сам arr .


arr = [ 1, 2, 15 ];
arr.sort();
alert(arr); //1, 15, 2

// Не заметили ничего странного в этом примере?
// Порядок стал 1, 15, 2 . Это неправильно! Но почему?

// Буквально, элементы преобразуются в строки при сравнении. Для строк применяется
// лексикографический порядок, и действительно выходит, что "2" > "15" .
// Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить
// функцию в качестве аргумента arr.sort() .
// Функция должна для пары значений возвращать:

function compareNumeric(a, b) {
    if (a > b) return 1; // если первое значение больше второго
    if (a == b) return 0; // если равны
    if (a < b) return -1; // если первое значение меньше второго
};

arr = [15, 2, 1];

alert(arr.sort(compareNumeric)); //1, 2, 15

// reverse
// Метод arr.reverse  меняет порядок элементов в arr на обратный.

arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1


// Метод str.split(delim) именно это и делает. Он разбивает строку на массив по заданному
// разделителю delim .
// В примере ниже таким разделителем является строка из запятой и пробела.

let names = "Маша, Вася, Петя";
arr = names.split(", ");
for(let name of arr){
    alert(`Сообщение получает ${name}`);
}


// Вызов arr.join(glue)  делает в точности противоположное split . Он создаёт строку из
// элементов arr , вставляя glue между ними.

arr = ["Вася", "Петя", "Маша"];
let str = arr.join(";");
alert(str); // Вася;Петя;Маша

// Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного
// сложнее. Они используются для вычисления какого-нибудь единого значения на основе
// всего массива.

let value = arr.reduce(function(previousValue, item, index, array) {
    // ...
}, [initial]);

    // Функция применяется по очереди ко всем элементам массива и «переносит» свой
    // результат на следующий вызов.
    // Аргументы:
    // previousValue – результат предыдущего вызова этой функции, равен initial при
    // первом вызове (если передан initial ),
    // item – очередной элемент массива,
    // index – его индекс,
    // array – сам массив.

arr = [1, 2, 3, 4, 5];
result = arr.reduce((sum, current) => sum + current, 0);
alert(result); //15

// Array.isArray(value). Он возвращает true , если value массив, и false , если
// нет.

alert(Array.isArray({})); // false
alert(Array.isArray([])); // true



