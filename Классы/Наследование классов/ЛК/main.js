// Допустим, у нас есть два класса.
//Animal:
class Animal{
    constructor(name){
        this.name = name;
        this.speed = 0;
    }
    run(speed){
        this.speed = speed;
        alert(`${this.name} бежит со скоростью ${speed}.`);
    }
    stop(){
        this.speed = 0;
        alert(`${this.name} стоит.`);
    }
}

let animal = new Animal("Мой питомец");


class Rabbit1{
    constructor(name){
        this.name = name;
    }
    hide(){
        alert(`${this.name} прячется!`);
    }
}

let rabbit1 = new Rabbit1("Мой кролик");

// Сейчас они полностью независимы.
// Но мы хотим, чтобы Rabbit расширял Animal . Другими словами, кролики должны
// происходить от животных, т.е. иметь доступ к методам Animal и расширять
// функциональность Animal своими методами.
// Для того, чтобы наследовать класс от другого, мы должны использовать ключевое слово
// "extends" и указать название родительского класса перед {..} .
// Ниже Rabbit наследует от Animal :

class Rabbit extends Animal{
    hide(){
        alert(`${this.name} прячется!`);
    }
}

let rabbit = new Rabbit("Белый кролик");
rabbit.run(5); //Белый кролик бежит со скоростью 5.
rabbit.hide(); //Белый кролик прячется!

// Теперь код Rabbit стал короче, так как используется конструктор класса Animal по
// умолчанию и кролик может использовать метод run как и все животные.

// Ключевое слово extends работает, используя прототипы. Оно устанавливает
// Rabbit.prototype.[[Prototype]] в Animal.prototype . Так что если метод не
// найден в Rabbit.prototype , JavaScript берёт его из Animal.prototype .


// После extends разрешены любые выражения
// Синтаксис создания класса допускает указывать после extends не только класс, но
// любое выражение.
// Пример вызова функции, которая генерирует родительский класс:

function f(phrase){
    return class{
        sayHI(){alert(phrase)};
    }
}

class User extends f("Привет"){};

new User().sayHI(); //Привет


// Здесь class User наследует от результата вызова f("Привет") .
// Это может быть полезно для продвинутых приёмов проектирования, где мы можем
// использовать функции для генерации классов в зависимости от многих условий и затем
// наследовать их.


// Переопределение методов

// Давайте пойдём дальше и переопределим метод. Сейчас Rabbit наследует от Animal
// метод stop , который устанавливает this.speed = 0 .

// Если мы определим свой метод stop в классе Rabbit , то он будет использоваться
// взамен родительского:

class Rabbit2 extends Animal {
    stop() {
    // ...будет использован для rabbit.stop()
    }
}

// Впрочем, обычно мы не хотим полностью заменить родительский метод, а скорее хотим
// сделать новый на его основе, изменяя или расширяя его функциональность. Мы делаем
// что-то в нашем методе и вызываем родительский метод до/после или в процессе.


// У классов есть ключевое слово "super" для таких случаев.
// super.method(...) вызывает родительский метод.
// super(...) вызывает родительский конструктор (работает только внутри нашего
// конструктора).


class Animal3{
    constructor(name){
        this.name = name;
        this.speed = 0;
    }
    run(speed){
        this.speed = speed;
        alert(`${this.name} бежит со скоростью ${speed}!`);
    }
    stop(){
        this.speed = 0;
        alert(`${this.name} остановился.`);
    }
}

class Rabbit3 extends Animal3{
    hide(){
        alert(`${this.name} прячется...`)
    }
    stop(){
        super.stop();
        this.hide()
    }
}

let rabbit3 = new Rabbit3("Чёрный кролик");

rabbit3.run(10); //Чёрный кролик бежит со скоростью 10!
rabbit3.stop(); //Чёрный кролик остановился. Чёрный кролик прячется...


// Теперь у класса Rabbit есть метод stop , который вызывает родительский
// super.stop() в процессе выполнения.

// Как упоминалось в главе Повторяем стрелочные функции, стрелочные функции не
// имеют super .
// При обращении к super стрелочной функции он берётся из внешней функции

class Rabbit4 extends Animal3 {
    stop() {
        setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды
    }
}

// В примере super в стрелочной функции тот же самый, что и в stop() , поэтому метод
// отрабатывает как и ожидается. Если бы мы указали здесь «обычную» функцию, была
// бы ошибка:



// Переопределение конструктора



// С конструкторами немного сложнее.
// До сих пор у Rabbit не было своего конструктора.
// Согласно спецификации  , если класс расширяет другой класс и не имеет конструктора,
// то автоматически создаётся такой «пустой» конструктор:

// class Rabbit extends Animal {
//     // генерируется для классов-потомков, у которых нет своего конструктора
//     constructor(...args) {
//         super(...args);
//     }
// }
    

// Если коротко, то в классах-потомках конструктор обязан вызывать super(...) , и (!)
// делать это перед использованием this .

// Конечно, всему есть объяснение. Давайте углубимся в детали, чтобы вы действительно
// поняли, что происходит.
// В JavaScript существует различие между «функцией-конструктором наследующего класса»
// и всеми остальными. В наследующем классе соответствующая функция-конструктор
// помечена специальным внутренним свойством [[ConstructorKind]]:"derived" .


// Разница в следующем:
// Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this .

// Когда запускается конструктор унаследованного класса, он этого не делает. Вместо
// этого он ждёт, что это сделает конструктор родительского класса.

// Чтобы конструктор Rabbit работал, он должен вызвать super() до того, как
// использовать this , чтобы не было ошибки:


class Animal5 {
    constructor(name){
        this.name = name;
        this.speed = 0;
    }
    run(speed){
        this.speed = speed;
        alert(`${this.name} бежит со скоростью ${speed}!`);
    }
    stop(){
        this.speed = 0;
        alert(`${this.name} остановился.`);
    }
}

class Rabbit5 extends Animal5{
    constructor(name, earLength){
        super(name);
        this.earLength = earLength;
    }
}

let rabbit5 = new Rabbit5("Piter the Bunny", 10);
alert(rabbit5.name); //Piter the Bunny
alert(rabbit5.earLength); //10

