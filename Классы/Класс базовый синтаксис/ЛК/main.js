// В объектно-ориентированном
// программировании класс – это расширяемый
// шаблон кода для создания объектов, который
// устанавливает в них начальные значения
// (свойства) и реализацию поведения (методы).

// Базовый синтаксис выглядит так:

// class MyClass {
//     // методы класса
//     constructor() { ... }
//     method1() { ... }
//     method2() { ... }
//     method3() { ... }
//     ...
// }
    

//пример

class User{
    constructor(name){
        this.name = name;
    }
    sayHi(){
        alert(`Hello, ${this.name}`);
    }
};

let user = new User("Dima");
user.sayHi(); //Hello, Dima

// Когда вызывается new User("Иван") :
// 1. Создаётся новый объект.
// 2. constructor запускается с заданным аргументом и сохраняет его в this.name

// Частая ошибка начинающих разработчиков – ставить запятую между методами класса,
// что приводит к синтаксической ошибке.
// Синтаксис классов отличается от литералов объектов, не путайте их. Внутри классов
// запятые не требуются.


// В JavaScript класс – это разновидность функции.

alert(typeof User); //function

// Вот что на самом деле делает конструкция class User {...} :

// 1. Создаёт функцию с именем User , которая становится результатом объявления класса.
// Код функции берётся из метода constructor (она будет пустой, если такого метода
// нет).
// 2. Сохраняет все методы, такие как sayHi , в User.prototype .

// 1) функция, созданная с помощью class , помечена специальным внутренним
// свойством [[FunctionKind]]:"classConstructor" . Поэтому это не совсем то же
// самое, что создавать её вручную.
// В отличие от обычных функций, конструктор класса не может быть вызван без new


// 2) Методы класса являются неперечислимыми. Определение класса устанавливает флаг
// enumerable в false для всех методов в "prototype" .
// И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы
// не хотим при этом получать методы класса.


// 3) Классы всегда используют use strict . Весь код внутри класса автоматически
// находится в строгом режиме.


// Как и функции, классы можно определять внутри другого выражения, передавать,
// возвращать, присваивать и т.д.
// Пример Class Expression (по аналогии с Function Expression):


let User2 = class{
    sayHi(){
        alert("Hello");
    }
};

// Аналогично Named Function Expression, Class Expression может иметь имя.
// Если у Class Expression есть имя, то оно видно только внутри класса:


let User3 = class MyClass{
    sayHi(){
        alert(MyClass);
    }
};

new User3().sayHi(); //выводит определение MyClass
let user3 = new User3;
user3.sayHi(); //выводит определение MyClass

//Мы даже можем динамически создавать классы «по запросу»:

function makeClass(phrase){
    return class{
        sayHi(){
            alert(`${phrase}, бабка умерла`)
        }
    }
};

let User4 = makeClass("Привет");
new User4().sayHi();
let user4 = new User4();
user4.sayHi(); 

// Геттеры/сеттеры, другие сокращения

// Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства,
// геттеры/сеттеры и т.д.
// Вот пример user.name , реализованного с использованием get/set :


class User5{
    constructor(name){
        this.name = name;
    }
    get name(){
        return this._name;
    }
    set name(value){
        if (value.length < 4){
            alert("Имя слишком короткое");
            return;
        } else{
            this._name = value;
        }
    }
}

let user5 = new User5("Димасик");
alert(user5.name); //Димасик
user5 = new User5("Ы"); //Имя слишком короткое


// Свойства классов

// В приведённом выше примере у класса User были только методы. Давайте добавим
// свойство:

class User6{
    name = "Анон";
    sayHi(){
        alert(this.name);
    }
}

let user6 = new User6();
user6.sayHi(); //Анон

// Свойство name не устанавливается в User.prototype . Вместо этого оно создаётся
// оператором new перед запуском конструктора, это именно свойство объекта.

